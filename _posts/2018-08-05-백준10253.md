---
layout: post
title:  "백준 10253번 헨리"
date:   2018-08-05 22:28:00 +0900
categories: 알고리즘
---
### 백준 10253번 헨리

1. 문제 : [https://www.acmicpc.net/problem/10253](https://www.acmicpc.net/problem/10253)

2. 풀이 : 문제에 적힌 점화식을 이용해서 구현했으나, 시간초과라는 결과를 얻었다. 내가 한 방식대로 2부터 시작해서 만족하는 부분분수를 찾는 것보다 짧은 시간에 결과를 얻을 수 있어야한다. 

   ![b10253f](https://user-images.githubusercontent.com/33653318/43686239-1a6b3510-98fd-11e8-8cf7-7e9d7a761cd8.PNG)

   1.번식은 문제에서 주어진 식인데, 그대로 사용하면 x1가 2일때부터 시작해서 숫자를 하나씩 키워가며 만족하는 값을 찾아야한다. 시간이 오래걸린다. 식을 바꿔보자.

   일단, 2번식으로 바꿔보자. 간단한 산수로 가능하다. 3.번식을 이제 생각해보자. x1는 b/a보다 크다는 조건을 만족하는 정수 중에 가장 작은 정수가 된다.  그 값은 b/a의 소수점을 뗀 값에 당연히 1을 더한 값이 된다.  예를 들어보자. b/a가 2.43일때 x1은 3이된다. 이 바꾼 식으로 반복문 없이 간단하게 만족하는 x1을 찾을 수 있다. 

   

   우리가 문제를 풀 때, 분수를 바로 계산하지 않고, 약분을 해가는 것처럼 코드를 구현해야 할 것 같다. 계속 분수를 컴퓨터가 계산하는 과정에서 double형이 한정된 크기를 갖기에 오차가 생기기 쉽다. 최대공약수를 구현해서 약분을 하자. 

3. 코드 :

   ```java
   	private int getLastHenry(int a, int b) {
   		int x;
   		while(a!=1) {
   			x = (b%a==0)? (b/a):(b/a+1);
   			a = a*x - b*1;		//분수와 분모를 따로 계산한다
               					//(분수뺄셈을 풀어쓴 것이다.)
   			b = b*x;				
   			int gcd = gcd(a,b);	//약분하기 위해 최대공약수
   			a/=gcd;
   			b/=gcd;
   		}
   		return b;
   	}
   	//최대공약수
   	private int gcd(int a, int b) {
   		return b==0?a:gcd(b,a%b);
   	}
   ```

   