---
layout: post
title:  "면접대비"
date:   2018-09-15 21:26:00 +0900
categories: 면접대비
---

---

### 인성면접

1. 자기소개

2. 어려웠던 일에 대한 대처

   발표울렁증, 결함이 새로운 기회가 될 수 있다고 느꼈습니다. 

3. 회사 지원동기

   저는 공부하고 이해한 내용을 누군가에게 도움이 될 수 있다는 생각으로 개인블로그에 공유하고 있습니다.  엑셈에 관련된 기사를 봤는데, "책쓰는 개발자가 모인 회사"라는 헤드라인이었습니다. 알고있는 기술을 기꺼이 공유하고 전체 산업발전에 기여하는 기업이었습니다. 그런 기업정신은 제가 생각하는 이상적인 기업의 모습이라 지원했습니다. 

   또, 플라밍고 같이 새로운 사업에 대담하게 도전하는 모습이 좋았습니다. 

4. 성격은 조화가 잘 되는지

   군생활에서 듣는 방법 배운거.

5. 어떻게 우리회사에 기여할 수 있는지? 채용해야하는 이유!!!!!

   (나를 팔아보세요!!  예시로 믿을 수 있게 해야한다. )

   IT업종에는 새로운 의겨닝 중요하다.  치킨 어떻게 처리했는지. 

   사소한 생각을 꾸준히 제시해 변화를 시도해 미래를 이끌어가는 데 도움이 될 수 있는 사람입니다. 

   

   개발부서간의 소통을 유연하게!!

   의사소통.. 듣는 것을 잘한다. 군대에서 느낌 토의방식으로 의사결정. 이런 방식으로 여태껏 팀활동에 큰 어려움이 없었기에, 자신있는 분야다. 

   서버 개발자는 다른 개발팀과 소통이 되야한다생각. 

   미래에 대한 대비로. 서버개발분야에는 인공지능 발전으로 대상자가 사람에서 사물로 발전.

   새로운 분야에 앞장서 의견을 주도할 수 있는 서버개발자. 

6. 장단점(다른 후보자보다 뛰어나다고 생각하는 것은?)

   다른 사람의 의견을 잘 듣는 것, 단은 필기하는 습관

7. 왜 개발이 하고 싶은지?

   아이디어를 표현할 수 있는 게 좋아서. 서버개발은 소켓 프로젝트 해본 결과, 의사소통 능력 활용해 가장 잘할 수 있는 일.

8. 실제로 서버개발이 무슨일을 하는지 아나?

   서버 개발은 서비스를 안정적으로 운영되도록 돕는 작업이다. 

   interMax나 maxGauge, 플라밍고같은 솔루션을 클라이언트에서 사용할 수 있도록 연결과 환경이 되는 서버를 구축하고 관리하는 것이라 알고 있습니다.  클라이언트 환경에서 데몬이나 에이전트관련 개발을 하는 것까지 입니다. 

9. 살면서 가장 열정적이었던 적은?

   전역후부터 가장 열정적이었다. 의무적인게 아니라, 내가 원해서 배우고싶은 공부기에.. 정말 열심히했다. 하루중 대부분의 시간은 개발 공부를 했다. 다들 여행가는데, 전역 5일후에 바로 학원다니면서 공부하고.. 그랬다.

10. 각 프로젝트 설명

   서버 프로젝트

   만남장소추천 프로젝트 

   영화관 프로젝트

11. 전공다르다. 왜 바꾸게 되었나?

    GIS프로그램에 필요한 다익스트라 알고리즘 구현하면서..  제가 실생활을 그대로 구현할 수 있다는 것이 좋았다. 그때 부터 전념해서 전공선택 과목 수강하면서 역량을 키웠다. 

12. 부족한 부분을 어떻게 메꿀 것인가?

    남들보다 더 노력할 생각이다. 부족하기에 일과이후 계속 공부하면서 금방 제 역할을 할 수 있을 것이다.

13. 관심기술

    요즈음에는 클라이드 컴퓨팅에 관심을 갖고 책을 찾아봤다. AWS로 구현했던 웹프로젝트를 구동해본 적도 있다. 무리하게 사용해서... 과금이 된 적도..있어서 지금은 꺼뒀다.

14. 데이터베이스 미래기술

    빅데이터가 발전하며 카산드라(Cassandra), 몽고DB(MongoDB), 카우치DB(CouchDB), 리아크(Riak), 네오포지(Neo4j) 등 빅데이터에 적합한 다양한 방식으로 쿼리가 가능하도록 더 많은 머신에 더 유연한 형태로 더 많은 데이터를 저장하도록 개발된 11종의 최신 데이터베이스마지막으로 할 말?

    만약 제가 이 면접에서 떨어진다면 어떤 이유때문일지?

----



### JAVA이론 정리

#### 자바의 특징

 OOP, 객체지향프로그래밍 언어이다.

 가비지를 통한 자동적인 메모리 관리

 JVM이 설치되면 모든 운영체제에 적용할 수 있다.

#### JVM(자바 가상 기계), 실행 원리

자바를 작동하게 하는 가상의 운영체제이다. 

소스파일을 만들고 컴파일을 하면(javac.exe) 바이트 코드 파일로(.class)로 만들어진다.  바이트코드는 JVM명령어 인데, 이것을 JVM이 런타임에(java.exe) 기계어로 번역한다.

#### 객체지향 프로그래밍(OOP)

Object-Oriented Programming, 데이터를 객체로 취급하여 순차적이 아닌 객체간의 상호작용으로 프로그램 이 작동되는 방식이다. 특징은 코드를 좀 더 직관적으로 알아볼 수 있고, 기능을 수정하고 추가하기 용이하다. 상속을 통해 코드의 재사용이 가능해 개발속도를 빠르게 해준다. 

#### 객체지향 언어의 특징

(상추캡이다)

상속 : 부모, 자식클래스 개념으로 부모자식의 변수와 메소드를 자식에서 사용할 수 있게 해주는 것.

추상화 : 객체들의 공통적인 특징을 뽑아내는 것.

캡슐화 :  필드와 메소드를 아무나 접근할 수 없게 접근 제한을 걸 수 있다.(접근제한자)

다형성 : 오버라이딩(재정의)와 상속을 이용해 다양한 객체를 처리할 수 있다.

#### 객체(Object)

주변에 존재하는 상태나 행동을 가지는 것들을 의미한다. 예를 들어, 자동차는 범퍼가 빨간색이라는 상태, 움 직인다는 상태가 존재한다. 프로그램에서는 상태가 변수가 되고 행동이 메서드가 된다.

#### 클래스

객체의 설계도, 객체를 정의해놓은 것.

#### 인스턴스

클래스로부터 객체를 만드는 과정을 인스턴스화, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.

#### 오버로딩 vs 오버라이딩

오버로딩은 같은 이름의 메소드를 여러개 정의하는 것.(매개변수의 타입이나 개수가 달라야한다.)

오버라이딩은 상속된 클래스가 부모의 메소드를 재정의해서 사용하는 것

#### 추상클래스, 인터페이스

추상클래스는 혼자서는 클래스 역할을 못한다. 상속을 통해 기능을 확장하는 목적의 클래스이다. 클래스 앞에 abstract가 붙는다.

인터페이스는 일종의 추상클래스이다. 인터페이스는 기능의 재정의에 목적을 둔다. 인터페이스는 제약사항이 있는데 모든 변수는 상수이고 메서드는 추상메소드여야 한다. 여러개의 인터페이스로부터 상속받는 것이 가능하다.(다중상속)

#### Static

클래스에 종속된 정보이다. 만들어낸 객체마다 다른 값이 아니고, 설계도(클래스)에 적용되는 정보이다. 그러므로 이 설계도를 사용한 모든 객체이 공유하는 값이다. 

Static메소드는 오직 static 필드값만 사용할 수 있다. 왜냐? static메소드는 객체가 생성되지 않은 상태에서도 사용되야하는데, 객체에 종속된 필드값이 있으면 안되지! 당연히 this키워드도 사용할 수 없다.

#### 싱글톤

클래스 인스턴스가 하나만 만들어지도록 하고, 그 객체는 전역에서 접근 가능하다. 장점은 객체를 한번만 생산하고 공유하기에 메모리 낭비를 막을 수 있다.  문제점은 너무 많은 데이터를 공유시키면 결합도가 높아져 객체지향에서 멀어진다. 즉, 수정이 어려워진다. 멀티쓰레드 환경에서 동기화를 안하면 인스턴스가 두개가 생성되는 경우도 있음. 

#### 동기화

다중 스레드에서 하나의 자료에만 접근할 때 사용한다. 예를 들어 내 계좌에 1000원이 있는 데, 빵을 사먹기위해 결제하는 동시에 1000원을 출금하는 경우.. 하나의 처리를 기다리지 않으면 1000원으로 2000원어치를 할 수 있는 문제가 발생한다. 이 경우를 막기위해 다중스레드 환경에서 하나의 접근을 잠시 막는 것이다.

#### 스크립트 언어와 컴파일 언어의 차이점

컴파일의 존재 여부, 컴파일 언어는 컴파일러를 통해서 한 번 컴파일 된 후에는 코드 수정 후 재 컴파일을 하기 전까지는 실행결과가 바뀌지 않는다. 스크립트는 실행할 때마다 변경된다.

#### 접근제한자

public : 접근 제한 없다. 

protected : 같은 패키지 내, 다른 패키지에서 상속받아 자손클래스에서 접근 가능

default : 같은 패키지 내에서만 접근 가능

private : 같은 클래스 내에서만 접근 가능

#### String, StringBuffer, StringBuilder 차이점

String객체는 한번 생성되면 변경이 불가능하다. 

StringBuffer와 StringBuilder는 생성해도 변경이 가능한데, 멀티쓰레도 상태에서 동기화 지원 여부가 다르다. StringBuffer는 멀티쓰레드 환경에서도 동기화가 보장되는 데, StringBuilder는 안된다.

#### 제네릭

여러가지 타입의 자료형이 다 적용되게 E등의 문자로 표현하는 것이다.  타입의 안정성과 코드 중복 제거의 문제해결을 위해 제네릭화 한다.  코드의 중복은 생각해보면 Object클래스를 이용해서도 할 수 있는데, Object를 일치하는 값으로 형변환을 하는 경우 타입이 안정하지 않아 런타임(실행)시 오류가 발생한다.  이것을 해결하고 코드 중복 제거하려고 제네릭이 나왔다. 

제네릭은 클래스 형태인데, int나 char같은 거는 객체가 아닌데 어떻게 적용되는 것인가? 내부에서 자동으로 기본자료형을 Wrapper형태로 만들어준다. (박싱)

#### 컬렉션

자주 사용되는 자료구조를 제공하는 클래스이다. 제네릭 형태로 정의되어 있어 여러 자료형에 두루 적용된다. 

#### 배열과 컬렉션의 차이

배열은 크기를 변경할 수 없다. 컬렉션은 가변적으로 크기를 변경할 수 있다. 컬렉션이 추가, 수정, 삭제도 간편하다. 

#### ArrayList와 LinkedList 차이

ArrayList는 데이터들이 순서대로 쭉 늘어선 배열 형식으로 연속으로 저장된다. 연산속도는 O(N)으로 일일이 하나씩 접근해서 탐색한다. 인덱스는 있기때문에 랜덤으로 해당하는 값에 접근은 가능하다. 자료의 갯수가 많으면 많을수록 탐색시간이 오래걸린다. 크기가 한정되어 있기에 포화상태가 잇다. 재조정할 수 있긴 한데, 상당한 연산량을 요구한다.  낭비되는 메모리가 많다.

LinkedList는 자료의 주소값으로 서로 연결되어 있는 구조이다. 저장공간에도 연속으로 저장되지 않는다.  무한의 데이터를 삽입할 수 있다. 단, 단방향이기에 순차접근으로만 데이터의 접근이 가능하다. 인덱스가 없기에 직접적인 데이터에 접근이 불가능하다. 

둘은 상황에 따라 적절히 적용한다. 

#### Iterator

컬렉션의 순차 검색을 위해 사용하는 클래스이다. Set같은 거는 Iterator로 하나하나의 변수에 접근한다. 형태는 테이블 형태로 하나의 요소씩 순차적으로 가리킨다.



---



### 소켓  네트워크

우리 통신할 때 전송할 패킷이 컴퓨터에서 랜 케이블로 나간다. 그 랜 케이블에서 라우터, DNS 순으로 패킷이 이동한다. 그 이동된 패킷은 다시 라우터를 타고 목표하는 컴퓨터로 전송되어 프로그램을 찾아 통신이 이루어진다. 이런 통신은 운영체제 단계(OSI 7계층)에서 설정되고, 프로그램을 작성할 때는 이 모든 설정 위에 꽂아서 쓴다라는 개념으로 소켓을 이용한 통신이된다. 

소켓 사용법과 흐름

소켓은 서버가 로컬 IP를 가지고 Port를 열고 클라이언트 접속을 기다린다. 클라이언트는 서버의 IP주소와 Port로 접속하여 연결되면, 서버와 클라이언트는 send, receive형태로 패킷을 주고 받는다. 서로의 통신이 끝나면 close로 접속을 끊는다.

### OSI 7계층

1계층 : 물리계층으로, 컴퓨터와  케이블 사이의 연결에 대한 규칙을 정한다.(인터페이스)

2계층 :  데이터링크계층으로, 망 내 컴퓨터의 연결에 대한 규칙을 정한다. LAN(이더넷), WAN

물리주소(MAC)가 나오는데 컴퓨터번호같은 개념이다. 망내는 무조건 전체전송이기에 주소에 해당하는 컴퓨터만 정보를 받고 나머지는 파기. 

3계층 : 네트워크 계층으로, 라우터 기기로 망 외 연결에 대한 규칙을 정한다. IP프로토콜. 라우팅 개념이 등장한다.  라우팅은 IP주소 가기까지 다음 라우터 주소 나타내는 것.

4계층 : 전송 계층, UDP TCP같이 전송의 신뢰성, 속도 등을 결정.

5계층 :  세션 계층, 서버나 컴퓨터 간의 대화를 정함.

6계층 :  언어나 암호화, 복호화를 결정하는 곳.

7계층 :  사용자에게 보여지는 계층으로 구글 크롬..인터넷익스플로러 같은 프로그램이다.

### 데몬

메모리에 상주하면서 요청오면 즉각 대응하는 프로세스.

### 에이전트

사용자나 컴퓨터 개입없이 특정업무를 사용자 대신 자율적으로 수행하는 S/W 

### 프로세스 vs 스레드

프로세스는 운영체제로 부터 자원을 할당받는 작업의 단위

스레드는 프로세스가 할당받은 자원내에 실행하는 단위 

그렇다면 왜 여러 프로세스로 할 수 있는 작업을 굳이 스레드로 나눌까?

작업 효율을 위해서이다. 프로세스를 생성해서 자원을 할당하는 시스템 콜이 줄어들어 효율적이다. 그리고 프로세스간의 통신보다 스레드간의 통신이 부담이 적다.

### HTTP의 GET과 POST비교

둘 다 HTTP 프로토콜을 이용하여 서버에 무엇인가를 요청할 때 사용하는 방식이다.

GET 방식은 요청하는 데이터가 HTTP Message의 Header부분의 url에 담겨서 전송된다. 주소에 포함되기에 크기에 제한이 있다. 보안이 필요한 데이터에는 적합하지않다.

POST방식은 HTTP Message의 Body부분에 담겨서 전송된다. 데이터크기나 보안 면에서 get보다 낫다.

### TCP vs UDP

UDP(User Datagram Protocol) 사용자 데이터그램 프로토콜은 비연결형 프로토콜이다. 손상되도 처리하지 않고 그냥 전송한다. 실시간 전송이 되고, 중간에 끊겨도 무시한다. 실시간 스트리밍이 예시이다. 

TCP(Transmission Control Protocol)은 순차적이고 소켓이라는 것을 통해 송신자와 수신자가 연결된다. 데이터를 안전하게 주고 받을 수 있지만, UDP와 반대로 느리다.

### HTTP의 문제점

평문 통신이라 도청이 가능하다. 암호화가 되지 않는다. HTTPS는 암호화를 더한 것이다. 단, 암호화통신은 CPU나 메모리가 많이 필요해서 민감한 정보를 다룰 때만 HTTPS 를 사용한다. 

